'''
作者:lg
日期:2019/9/7
文件描述:set的基本属性和操作方法
缺陷：
'''

# 特点:set是一个不常用的数据结构,因为set的元素具有'不重复,无序,可哈希'的特点,相当于字典里面的Key

# set元素中不能嵌套set,因为set是不可哈希的
#         s1 = {1, 2, 3}
#         s2 = {'a', 'b', s1}
# 结果:TypeError: unhashable type: 'set'

# set常用作去重的功能
# 去掉下面列表中重复的元素
l = [1, 2, 3, 4, 45, 45, 56, 3, 34, 3, 4, 1, 1, 1, 34, 45, 34, 5, 4]
s = set(l)
print(s)
l = list(s)
print(l)

# 增删改查
# 增加
s = {"刘嘉玲", '关之琳', "王祖贤"}
s.add("郑裕玲")
print(s)
s.add("郑裕玲")  # 重复的内容不会被添加到set集合中
print(s)
s = {"刘嘉玲", '关之琳', "王祖贤"}
s.update("麻花藤")  # 迭代更新(联想--->列表的迭代添加用extend)
print(s)
s.update(["张曼⽟", "李若彤", "李若彤"])
print(s)

# 删除
s = {"刘嘉玲", '关之琳', "王祖贤", "张曼⽟", "李若彤"}
item = s.pop()  # 随机弹出⼀个.
print(s)
print(item)
s.remove("关之琳")  # 直接删除元素
# s.remove("⻢⻁疼") # 不存在这个元素. 删除会报错
print(s)
s.clear()  # 清空set集合.需要注意的是set集合如果是空的. 打印出来是set() 因为要和dict区分的.
print(s)  # set()

# 修改
# set集合中的数据没有索引. 也没有办法去定位⼀个元素. 所以没有办法进⾏直接修改.
# 我们可以采⽤先删除后添加的⽅式来完成修改操作
s = {"刘嘉玲", '关之琳', "王祖贤", "张曼⽟", "李若彤"}
# 把刘嘉玲改成赵本⼭
s.remove("刘嘉玲")
s.add("赵本⼭")
print(s)

# 查询
# set是⼀个可迭代对象. 所以可以进⾏for循环
for el in s:
    print(el)

# 集合常见操作
s1 = {"刘能", "赵四", "⽪⻓⼭"}
s2 = {"刘科⻓", "冯乡⻓", "⽪⻓⼭"}
# 交集
# 两个集合中的共有元素
print(s1 & s2)  # {'⽪⻓⼭'}
print(s1.intersection(s2))  # {'⽪⻓⼭'}
# 并集
print(s1 | s2)  # {'刘科⻓', '冯乡⻓', '赵四', '⽪⻓⼭', '刘能'}
print(s1.union(s2))  # {'刘科⻓', '冯乡⻓', '赵四', '⽪⻓⼭', '刘能'}
# 差集
print(s1 - s2)  # {'赵四', '刘能'} 得到第⼀个中单独存在的
print(s1.difference(s2))  # {'赵四', '刘能'}
# 反交集
print(s1 ^ s2)  # 两个集合中单独存在的数据 {'冯乡⻓', '刘能', '刘科⻓', '赵四'}
print(s1.symmetric_difference(s2))  # {'冯乡⻓', '刘能', '刘科⻓', '赵四'}
s1 = {"刘能", "赵四"}
s2 = {"刘能", "赵四", "⽪⻓⼭"}
# ⼦集
print(s1 < s2)  # set1是set2的⼦集吗? True
print(s1.issubset(s2))
# 超集
print(s1 > s2)  # set1是set2的超集吗? False
print(s1.issuperset(s2))



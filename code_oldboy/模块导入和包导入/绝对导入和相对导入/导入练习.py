'''
作者:lg
日期:2019/10/30
文件描述:
缺陷：
'''

# 绝对导入:
# 主执行文件和包目录的位置是相对固定的,主执行文件的位置不能随意更改,因为主执行文件所在目录就是根目录!!
# 相对导入:
# 包可以被任何人使用,无论执行文件在哪个位置

# 绝对导入与相对导入的另一个去区别:!!!!!
# from ...glance_o import say  # ValueError: attempted relative import beyond top-level package解析:
# 相对导入的最顶层就是包里面的那层目录,千万不能从包里出去访问其他目录(包括和包同级的目录),
# 原因:包是允许放在任何地方的,所以它所在的目录里的其他文件都是随时可变的,包内部的文件千万不可以对外部文件有依赖!!!!!
# import a ,a即是这个包
# from glance_o import say解析:
# 绝对导入只需注意主执行文件所在的根目录,根目录里的所有目录都可以被from...这样导入

# 相对导入为什么不能在包里执行模块文件了?
# 包里执行文件的话,基本上点点都是越过包的最顶层位置的(主执行文件import导入的就是包),这是非法的
# 所以说,相对导入和包是密切联系的,没有包就没用相对导入,但是没有相对导入是可以有包的,包是相对导入充分非必要条件!!!

# !!!!!总结!!!!!使用"相对导入"记住这两点!!!!!
# 1,使用范围:使用相对导入 '.' 必须在'包的内部'才可以
# 2,主执行文件是不能用'.'这种相对导入方式的,使用点的相对导入,必须满足主执行文件在这个文件的外层
# 3,使用条件:点点寻找目录的时候不能越过包的外面,包内部文件不允许与包外部文件有联系


# from . import 变量名!!!!!
# 解析: '.' 点表示我不管当前目录到底在哪,我只管从当前的目录导入一个模块,存放在当前命名空间里

import glance

glance.api.policy.get()

# from ... import * 与 __all__联用:
# 在包里,如果*是一个文件夹里所有的文件,那么用__init__文件里的__all__来控制哪些变量名会被导入

'''
作者:lg
日期:2019/10/28
文件描述:
缺陷：
'''

# 模块:就是一个单独的py文件




# 导入模块通常写在文件最上方
# 一般导入模块的顺序:
# 内置模块
# 扩展模块
# 自定义的

# 模块导入原理:
# 先从sys.modules里查看这个模块是否已经被导入,如果被导入了就直接引用,不进行下面操作,
# 如果没有被导入,就根据sys.path里的路径依次去寻找模块名字,如果找到了就导入,
# 然后创建这个模块命名空间,执行文件,把文件里所有的变量名放在模块的命名空间里,
# 如果所有路径没找到,就报错

import sys

print(sys.modules)
print(sys.path)

# 给模块起别名
# import 模块1 as 模块2

# 应用场景:两个模块只是名字不同,但是拥有的方法基本一样

#         if sql == 'Mysql':
#             import Mysql as db
#         elif sql == 'oracle':
#             import oracle as db

#         db.func1()
#         db.func2()


# from ... import ...
# from:根据sys.path来寻找模块名
# import:在导入文件模块情况下,会把import后面的名字导入到当前命名空间里,可直接使用

# from ... import * 与 __all__关键词联用:
# 当__all__不存在时,'*'会导入所有变量
# __all__:里面存着一个字典,存放变量名,只有列表里的变量名会被导入


# import...与from ... import ...的比较:
# import: 直接把一个文件里的所有变量导入到模块内存空间里,非常占用内存,但是不会与当前命名空间的变量冲突
# from ... import:只把import后面的变量名导入到当前命名空间里,占用很少的内存,但是会与当前命名空间的变量发生冲突(直接覆盖 )

# 一种应用场景:模块文件既可以单独执行调试时,也可以被当做模块导入使用!!!!!
if __name__ == '__main__':
    pass
# 当文件是主执行文件时,__name__是__main__;当文件被当做模块导入时,__name__是文件名字(模块名字);
